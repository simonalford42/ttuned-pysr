"""
Expression parser for converting string expressions back to Node trees.
Handles the format generated by Node.__str__: terminals as values, ops as (left op right).
"""

import re
from basic_sr import Node


class ExpressionParser:
    """Parser for converting string expressions to Node trees"""
    
    def __init__(self):
        self.operators = {'+', '-', '*', '/'}
    
    def tokenize(self, expr):
        """Tokenize expression string into meaningful tokens"""
        # Remove extra whitespace
        expr = expr.strip()
        
        # Split on parentheses and operators while keeping them
        tokens = []
        current_token = ""
        
        for char in expr:
            if char in '()+-*/':
                if current_token.strip():
                    tokens.append(current_token.strip())
                    current_token = ""
                if char != ' ':  # Skip spaces
                    tokens.append(char)
            elif char == ' ':
                if current_token.strip():
                    tokens.append(current_token.strip())
                    current_token = ""
            else:
                current_token += char
        
        if current_token.strip():
            tokens.append(current_token.strip())
        
        return [t for t in tokens if t]  # Remove empty tokens
    
    def parse_terminal(self, token):
        """Parse a terminal token (variable or constant)"""
        if token.startswith('x') and len(token) > 1 and token[1:].isdigit():
            return Node(token)  # Variable like x0, x1, etc.
        
        try:
            # Try to parse as float
            return Node(float(token))
        except ValueError:
            pass
        
        try:
            # Try to parse as int
            return Node(int(token))
        except ValueError:
            pass
        
        raise ValueError(f"Cannot parse terminal: {token}")
    
    def parse_expression(self, tokens, pos=0):
        """
        Recursively parse expression tokens into Node tree.
        Returns (node, next_position)
        """
        if pos >= len(tokens):
            raise ValueError("Unexpected end of expression")
        
        token = tokens[pos]
        
        # If it's an opening parenthesis, parse a binary operation
        if token == '(':
            # Parse: (left op right)
            if pos + 4 >= len(tokens):
                raise ValueError("Incomplete parenthesized expression")
            
            # Parse left operand
            left, next_pos = self.parse_expression(tokens, pos + 1)
            
            # Get operator
            if next_pos >= len(tokens):
                raise ValueError("Missing operator")
            operator = tokens[next_pos]
            if operator not in self.operators:
                raise ValueError(f"Invalid operator: {operator}")
            
            # Parse right operand
            right, next_pos = self.parse_expression(tokens, next_pos + 1)
            
            # Expect closing parenthesis
            if next_pos >= len(tokens) or tokens[next_pos] != ')':
                raise ValueError("Missing closing parenthesis")
            
            return Node(operator, left, right), next_pos + 1
        
        # Otherwise, it's a terminal
        elif token != ')':
            return self.parse_terminal(token), pos + 1
        
        else:
            raise ValueError(f"Unexpected token: {token}")
    
    def parse(self, expr_string):
        """Parse expression string into Node tree"""
        if not expr_string or not expr_string.strip():
            raise ValueError("Empty expression")
        
        tokens = self.tokenize(expr_string)
        if not tokens:
            raise ValueError("No tokens found")
        
        node, final_pos = self.parse_expression(tokens, 0)
        
        # Should have consumed all tokens
        if final_pos != len(tokens):
            raise ValueError(f"Unexpected tokens after parsing: {tokens[final_pos:]}")
        
        return node


def test_parser_examples():
    """Test parser with various expression examples"""
    parser = ExpressionParser()
    
    test_cases = [
        # Simple terminals
        "x0",
        "x1", 
        "1.0",
        "2.0",
        
        # Simple operations
        "(x0 + 1.0)",
        "(x0 * 2.0)",
        "(x0 - x1)",
        "(x1 / x0)",
        
        # Nested operations
        "(x0 * (x1 + 1.0))",
        "((x0 + x1) * 2.0)",
        "(x0 + (x1 * 2.0))",
        
        # Complex expressions from dataset
        "(((2.0 * ((x0 * x0) / (1.0 / (x0 + 1.0)))) + 2.0) + 2.0)",
        "((((1.0 / x0) - ((x2 * 2.0) + x2)) - x2) * x0)",
    ]
    
    print("=== Testing Expression Parser ===")
    success_count = 0
    
    for i, expr in enumerate(test_cases):
        try:
            # Parse string to Node
            parsed_node = parser.parse(expr)
            
            # Convert Node back to string
            reconstructed = str(parsed_node)
            
            # Check if they match (allowing for some formatting differences)
            success = expr == reconstructed
            
            if success:
                success_count += 1
                status = "✓"
            else:
                status = "⚠"
            
            print(f"{status} Test {i+1}: {expr}")
            if not success:
                print(f"    Reconstructed: {reconstructed}")
                
        except Exception as e:
            print(f"❌ Test {i+1}: {expr}")
            print(f"    Error: {e}")
    
    print(f"\nParser test results: {success_count}/{len(test_cases)} passed")
    return success_count == len(test_cases)


def test_back_and_forth_with_dataset(dataset_file, num_samples=100):
    """Test parser with expressions from actual dataset"""
    import json
    
    parser = ExpressionParser()
    print(f"\n=== Testing Parser with Dataset: {dataset_file} ===")
    
    # Read sample expressions from dataset
    expressions = []
    with open(dataset_file, 'r') as f:
        for i, line in enumerate(f):
            if i >= num_samples:
                break
            data = json.loads(line)
            expressions.append(data['target'])
    
    success_count = 0
    total_count = len(expressions)
    
    for i, expr in enumerate(expressions):
        try:
            # Parse and reconstruct
            parsed_node = parser.parse(expr)
            reconstructed = str(parsed_node)
            
            success = expr == reconstructed
            if success:
                success_count += 1
            elif i < 10:  # Show first 10 failures for debugging
                print(f"⚠ Mismatch {i+1}:")
                print(f"    Original:      {expr}")
                print(f"    Reconstructed: {reconstructed}")
                
        except Exception as e:
            if i < 10:  # Show first 10 errors for debugging
                print(f"❌ Parse error {i+1}: {expr}")
                print(f"    Error: {e}")
    
    print(f"\nDataset parsing results: {success_count}/{total_count} ({100*success_count/total_count:.1f}%) passed")
    return success_count, total_count


if __name__ == "__main__":
    import argparse
    
    parser = argparse.ArgumentParser(description="Test expression parsing")
    parser.add_argument("--test-examples", action="store_true", help="Test with hardcoded examples")
    parser.add_argument("--test-dataset", type=str, default="data/harder_problems_one_step_train.jsonl", 
                       help="Test with dataset file")
    parser.add_argument("--num-samples", type=int, default=100, help="Number of dataset samples to test")
    
    args = parser.parse_args()
    
    if args.test_examples:
        test_parser_examples()
    
    if args.test_dataset:
        test_back_and_forth_with_dataset(args.test_dataset, args.num_samples)